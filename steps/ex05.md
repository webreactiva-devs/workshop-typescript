
# 5. Uniones, literales y alias


## UniÃ³n de tipos

>  Cuando un valor puede ser de varios tipos

```ts
let temperature: string | number 
temperature = '10Âº'
temperature = 11
temperature = [-3, 2] // ğŸš«
```

âš¡ï¸En el siguiente paso veremos `any` 

## Tipos literales

> Un literal es un subtipo mÃ¡s concreto de un tipo colectivo. Los tipos literales sirven para crear tipos en funciÃ³n de otros. 

```ts
type yearSeasons = 'spring' | 'summer' | 'autumn' | 'winter'
let year2024: yearSeasons
year2024 = 'spring'
year2024 = 'verano' // ğŸš«

type fruits = ['apples', 'oranges'] | ['pears', 'apricots']
let myFruits: fruits = ["pears", "apricots"];
myFruits = ['oranges']  // ğŸš«
```

## Alias de tipos (Type Alias)

> Un alias de tipo es un nombre concreto para un tipo de dato en base a otros. AsÃ­ es mÃ¡s fÃ¡cilmente reproducible

```ts
type ID = number | string
const id1: ID = 45345
const id2: ID = "45345"
const id3: ID = false // ğŸš«

type temperatures = (number | string)[]
let myTemperatures:  temperatures = ['10', '-5']
myTemperatures = [7, -1]
myTemperatures = ['15', 0]
myTemperatures = [false, 1] // ğŸš«
```


## ğŸ’¦ Para que lo resuelvas tÃº



ğŸ›  Tienes que crear dos variables, `elem1` y `elem2`.  Si los dos son nÃºmeros, entonces consigue la suma. Si son dos cadenas de texto, tambiÃ©n las tiene que sumar.

ğŸ¤™ Tip: Usa `typeof`



<details><summary>SoluciÃ³n</summary>

```ts
let elem1: number | string = 3 
let elem2: number | string = 5

if (typeof elem1 === "number" && typeof elem2 === "number") {
  console.log(elem1 + elem2);
}
if (typeof elem1 === "string" && typeof elem2 === "string") {
  console.log(Number(elem1) + Number(elem2));
}

```

</details>


âš¡ï¸Explicar el concepto de â€˜type guardsâ€™ o â€˜reestricciÃ³n de tiposâ€™


ğŸ›  Crea un nuevo _type alias_ llamado `speed` que pueda ser tanto un nÃºmero como una cadena de texto
- Crea un _type alias_ llamado `Car` que sea un objeto con una clave `groundSpeed` que pueda ser tanto un nÃºmero como una cadena
- Crea un _type alias_ llamado `Plane` que sea un objeto con una clave `groundSpeed`  como la de `Car` y tambiÃ©n una clave `skySpeed` con las mismas condiciones de `groundSpeed`



<details><summary>SoluciÃ³n</summary>

```ts
type speed = number | string;
type Car = { groundSpeed: speed };
type Plane = { groundSpeed: speed, skySpeed: speed };

let myCar: Car = { groundSpeed: "100" }
console.log(myCar.groundSpeed)

let myPlane: Plane = { groundSpeed: 10, skySpeed: 800 };
console.log(myPlane);
```

</details>


ğŸ›   Â¿Quieres rizar el rizo? Cambia el tipo `speed`  para que sea una funciÃ³n que devuelve un nÃºmero y adapta el cÃ³digo.



<details><summary>SoluciÃ³n 2</summary>

```ts
type speed = () => number;
type Car = { groundSpeed: speed };
type Plane = { groundSpeed: speed, skySpeed: speed };

let myCar: Car = {
  groundSpeed: () => {
    return 100
  }
};
console.log(myCar.groundSpeed());

let myPlane: Plane = {
  groundSpeed: () => {
    return 10
  },
  skySpeed: ()  => {
    return 800
  }
};
console.log(myPlane);
```

</details>



ğŸ Bravo, a por el siguiente!